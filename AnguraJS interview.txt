
AngularJS is an open-source JavaScript framework developed by Google. It is a structural framework for dynamic Web apps. It is easy to update and get information from your HTML document. It helps in writing a proper maintainable architecture, that can be tested at a client side code.

This framework is developed on MVC (Model-View-Controller) design pattern.
It provides full featured SPA (Single Page Application) framework.
It supports Dependency Injection.
It supports two-way data binding.
It provides routing features.
Testing was designed right from the beginning; so you can build robust tests.
For DOM manipulation, jqLite is built-in; which is kind of like the Mini-Me of jQuery.
Separation of the client side of an Application from the Server side.
The AngularJS framework uses Plain Old JavaScript Objects(POJO), it doesn’t need the getter or setter functions.

Explain Directives in AngularJS?
AngularJS directives are only used to extend HTML and DOM elements' behavior. These are the special attributes, that start with ng- prefix, that tell AngularJS's HTML compiler ($compile) to attach a specified behavior to that DOM element.
You can invoke a directive by using:
Element name
Attribute
Class
Comment
The legal restrict values are:
E for Element name
A for Attribute
C for Class
M for Comment
mainApp.directive('student', function() {
   //define the directive object
   var directive = {};
   
   //restrict = E, signifies that directive is Element directive
   directive.restrict = 'E';
   
   //template replaces the complete element with its text. 
   directive.template = "Student: <b>{{student.name}}</b> , Roll No: <b>{{student.rollno}}</b>";
   
   //scope is used to distinguish each student element based on criteria.
   directive.scope = {
      student : "=name"
   }
   
   //compile is called during application initialization. AngularJS calls it once when html page is loaded.
	
   directive.compile = function(element, attributes) {
      element.css("border", "1px solid #cccccc");
      
      //linkFunction is linked with each element with scope to get the element specific data.
      var linkFunction = function($scope, element, attributes) {
         element.html("Student: <b>"+$scope.student.name +"</b> , Roll No: <b>"+$scope.student.rollno+"</b><br/>");
         element.css("background-color", "#ff00ff");
      }
      return linkFunction;
   }
   return directive;
});




AngularJS has a set of built-in directives like
ngBind,
ngModel
ngClass
ngApp
ngInit
ngRepeat

What are expressions in AngularJS?
Expressions in AngularJS are just like JavaScript code snippets. JavaScript code is usually written inside double braces: {{expression}}. In other words, Angular Expressions are JavaScript code snippets with limited subset. Expressions are included in the HTML elements. 

What is $scope in AngularJS?
$scope in AngularJS is an object which refers to an application model
It is an object that binds view (DOM element) with the controller. In controller, model data is accessed via $scope object. As we know, AngularJS supports MV* pattern, $scope object becomes the model of MV*. 
Every AngularJS application has a $rootScope that is the top most scope created on the DOM element which contains the ng-app directive.

<script src="~/Script/angular.min.js"></script> 
<body ng-app="myapp">
<div ng-controller="ParentController">  
var app = angular.module("myapp", []);  
 app.controller("ParentController", function($scope)   
{$scope.parentName = "Parent Controller"; });  

What is SPA (Single page application) in AngularJS?
Single-Page Applications (SPAs) are web applications that load a single HTML page and dynamically update that page as the user interacts with the app. SPAs use AJAX and HTML to create fluid and responsive web apps, without constant page reloads. However, this means much of the work happens on the client side, in JavaScript.


How to implement routing in AngularJS? Explain $routeProvider in AngularJS?
var app = angular.module("AngularApp", ['ngRoute']);  
app.config(['$routeProvider',  
    function($routeProvider)  
    {  
        $routeProvider.  
        when('/page1',   
             {  
                templateUrl: 'Modules/Page1/page1.html',  
                controller: 'Page1Controller'  
            })  
            .  
        otherwise  
        ({  
            redirectTo: '/page1'  
        });  
    }  
]);  


What are the services in AngularJS?
In general services are functions that are responsible for specific tasks in an application. AngularJS services are designed based on two principles.
Lazily instantiated 
Angular only instantiates a service when an application component depends on it, using dependency injection 
Singletons
Each component is dependent on a service that gets a reference to the single instance generated by the service factory.
AngularJS provides many built in services, for example, $http, $route, $window, $location
The AngularJS Module defines three methods for defining services : factory, service and provider. The result of using these methods is the same – a service object 

What is a Factory method in AngularJS?
AngularJS Factory: the purpose of Factory is also the same as Service, however in this case we create a new object and add functions as properties of this object and at the end we return this object.
One major difference I see is that you can run custom code in the factory. But, in a service, only object creation happens.
module.factory( 'factoryName', function ); 

Explain Provider Method in AngularJS.
The Module.provider method allows you to take more control over the way that a service object is created or configured. The arguments to the provider method are the name of the service that is being defined and a factory function. The factory function is required to return a provider object that defines a method called $get, which in turn is required to return the service object. When the service is required, AngularJS calls the factory method to get the provider object and then calls the $get method to get the service object. Using the provider method doesn’t change the way that services are consumed, which means that I don’t need to make any changes to the controller or directive in the example.
The advantage of using the provider method is that you can add functionality to the provider method that can be used to configure the service object.
serviceApp.provider("logService", function()  

Explain what is Dependency Injection in AngularJS?
It is a software design pattern in which objects are passed as dependencies. It helps us to remove hard coded dependencies and makes dependencies configurable. Using Dependency Injection, we can make components maintainable, reusable and testable.
Separating the process of creation and consumption of dependencies.
It allows us to create independent development of the dependencies.
We can change the dependencies when required.
It allows injecting mock objects as dependencies for testing.
AngularJS uses dependency with several types
Value
Factory
Service
Provider
Constant
AppModule.controller("AppController", function($scope, $window, $log,$http)   
{   
  
});   

What is controller in AngularJS?
A controller is a set of JavaScript functions which is bound to a specified scope, the ng-controllerdirective. Angular will instantiate the new controller object, and injects the new scope as a dependency. It contains business logic for the view and avoids using controller to manipulate the DOM. 

What are the filters in AngularJS?
Filters are used to modify the data and can be added in expression or directives using a pipe character. A filter formats the value of an expression for display to the user. They can be used in view templates, controllers, or services, and we can easily create our own filter. Filter is a module provided by AngularJS. 
currency
date
filter
json
limitTo
lowercase
number
orderBy
uppercase
{{ x | lowercase }}

Explain Module And Controller In AngularJS.
AngularJS module is a container of all angular components like controller, services, directive, filter, config etc



ng-app directive 
is used to define AngularJS applications.
It designates the root element of AngularJS application 
We can define any number of ng-app directives inside the HTML document but only one AngularJS application can be bootstrapped automatically (auto-bootstrapped, with ng-app directive in the html tag, we can not use js code); 
the other applications needs to be bootstrapped manually(without ng-app directive in the html tag, But we will be initializing the app from JavaScript. 
var app = angular.module("app", []);  
angular.bootstrap(document.getElementById("container"), ["app"])   ). 


What is Representational State Transfer(REST) in AngularJS.
REST is a style of API that operates over HTTP requests. The requested URL identifies the data to be operated on, and the HTTP method identifies the operation that is to be performed. 
A web service is RESTful when :
It’s URL-based (e.g., http://www.micbutton.com/rs/blogPost).
It uses an Internet media type such as JSON for data interchange.
It uses standard HTTP methods (GET, PUT, POST, DELETE).

The $http service is used to make and process Ajax requests, which are standard HTTP requests that are performed asynchronously.
testApp.controller("ajaxController", function($scope, $http)  
{  
    $scope.loadData = function()  
    {  
        $http.get("data.json").success(function(data)  
        {  
            $scope.products = data;  
        });  
    }

Why to use AngularJS Global Object services?
The main reason that AngularJS includes these services is to make testing easier, but an important facet of unit testing is the need to isolate a small piece of code and test its behavior without testing the components it depends on—in essence, creating a focused test. The DOM API exposes functionality through global objects such as document and window. 

What is event handling in AngularJS?
AngularJS has a simple model for how to add event listeners. We can attach an event listener to an HTML element using one of the following AngularJS event listener directives.
ng-click
ng-dbl-click
ng-mousedown
ng-mouseup
ng-mouseenter
The event listener functions called are functions added to the $scope object by the controller function.

What is Constants in AngularJS?
Constant are like services in AngularJS in which we can define our global data. It is declared using "constant" keyword.
As we define our app-keys in Web.Config file for ASP.NET application, which further we can use anywhere in the application, likewise we can declare constant data in AngularJS globally that can be used throughout the application.
We can inject Constant everywhere in controller or service like any other dependency (e.g.$http).AngularJS uses Singleton structure for creating Constant dependency in our Angular application.
app.constant('config',  
{  
    appName: 'Constants',  
    appVersion: 2.0  
});  
Now, use the above to declare Constant in our controller,
app.controller('mainController', function ($scope,config) {   
 $scope.ApplicationName = config.appName;   
}   

What is ngClass directive in AngularJS?
Add/Remove classes based on Angular variables.
Add/Remove classes based on evaluated expressions.
Bind single or multiple classes based on dynamic data.
<div ng-class="{class1 : expression1, class2 : expression2}">  
    Hello World!  
</div>  

Why is scopeless controller used in AngularJS?
Sometimes controller become complex by using $scope for providing data and behavior to view, in that situation we can use scopeless controller. 
But if you have designed your AngularJS application perfectly, there is no need to go for scopeless controllers.
Creating scope-less controller
angular module(app.js):
angular.module('myApp', []);
var app = angular.module("myApp");  
app.controller("myController", function()   
{  
    this.title = 'scopeless Controller Test';  
    this.name = 'Anupam';  
    this.sayHello = function()   
    {  
        alert('Hello ' + this.name);  
    }  
}); 
<html ng-app="myApp" ng-controller="myController as ctrl">  
<div class="well-lg">  
                    Hi {{ctrl.name}}  
                </div>  


Основной формой организации приложений в AngularJS являются модули. Модуль представляет хранилище различной информации: директив, фильтров, контроллеров и т.д. При этом одно приложение может иметь несколько модулей. Например, разные модули могут представлять какую-либо специфическую функциональность.

Для создания модуля используется метод angular.module(). Этот метод принимает три параметра, два из которых являются обязательными:
Название модуля. Согласно соглашениям о наименовании модуль должен иметь суффикс App
Набор других модулей в виде строкового массива, от которых данный модуль зависит
Конфигурационные настройки модуля
В качестве результата метод angular.module() возвращает объект Module.
Для создания модуля используется метод angular.module(). Этот метод принимает три параметра, два из которых являются обязательными:
var myApp = angular.module('myApp', []);

Используя модуль, мы можем определить ряд компонентов, таких как контроллеры, сервисы и т.д., которые затем применяются в приложении. Для этого объект Module имеет ряд методов, наиболее используемые из них:
config(callback): регистрирует функцию callback, которая используется для его конфигурации в процессе загрузки
constant(key, value): определяет сервис, который возвращает константное значение value
controller(name, constructor): создает контроллер
directive(name, factory): создает директиву, которая расширяет стандартную разметку html
factory(name, provider): создает службу
filter(name, factory): создает фильтр
provider(name, type): создает сервис
service(name, constructor): создает сервис

Контроллер
В Angular контроллер является функцией - для расширения экземпляров областей видимости, за исключением корневой области
создание контроллера
myApp.controller("phonesController", function ($scope) {
    // настройка контроллера
});

контроллер
|
V
скоуре
^
|
V
вью

Объект $scope
Объект $scope служит связующим звеном между представлением в виде кода html и контроллером. Объект $scope выполняет роль модели приложения.
Каждое приложение AngularJS имеет один объект $rootScope, который является родительским по отношению ко всем остальным объектам $scope, которые используются в контроллерах. И при запуске приложения создается привязка элемента, в котором используется директива ng-app, к объекту $rootScope.

директива ng-app привязывается к объекту $rootScope

Директива ng-controller создает новый объект $scope, который является дочерним по отношению к глобальному $rootScope и который переопределяет его действие. В то же время область действия объекта $scope, установленного в контроллере, задается только этим блоком div, и вне его $scope уже не действует.

Директива
Директивы описывают изменение поведения или преобразование DOM модели, связанное с пользовательским атрибутом, именем элемента, или css классом. Директивы позволяют расширить HTML-синтаксис в декларативной форме.
кастомная директива
questApp.directive("answerList", function () {
    return function (scope, element, attrs) {
        var data = scope[attrs["answerList"]];
        if (angular.isArray(data.answers)) {
            var ulElem = angular.element("<ul>");
            element.append(ulElem);
            for (var i = 0; i < data.answers.length; i++) {
                var liElem = angular.element('<li>');
                liElem.append(angular.element('<p>').text(data.answers[i].text));
                ulElem.append(liElem);
            }
        }
    }
});
теперь тоже но более расширенно
questApp.directive("answerList", function () {
    return {
        link: function (scope, element, attrs) {
         
            var data = scope[attrs["answerList"] ||attrs["source"]];
             
            if (angular.isArray(data.answers)) {
тут много кода для создания вставки элементов с помощью джаваскрипт
                }
            }
        },
        restrict: "EACM"
    }
});
теперь тоже но с шаблоном
questApp.directive("answerList", function () {
    return {
        link: function (scope, element, attrs) {
         
            scope.data = scope[attrs["answerList"]];
        },
        restrict: "A",
        template: "<div class='answers'>" +
        "<div ng-repeat='answer in data.answers' class='answer'>" +
            "<div class='vote'>" +
            "<a class='vote-up' ng-click='voteUp(answer)'></a>" +
            "<span class='rate'>{{answer.rate}}</span>" +
            "<a class='vote-down' ng-click='voteDown(answer)'></a>" +
        "</div>" +
        "<b>{{answer.text}}</b>" +
        "<p>{{answer.author}}</p>" +
        "<p><i>{{answer.date}}</i></p>" +
    "</div></div>"
    }
});
тоже самое с внедрением шаблонов
questApp.directive("answerList", function () {
    return {
        restrict: "A",
        templateUrl: "templates/answersTemplate.html",
        transclude: true
    }
});
Свойство link позволяет задать функцию директивы. А свойство 
restrict позволяет указать объект, к которому директива будет применяться. Оно может иметь следующие значения:
E: директива применяется к элементу
A: директива применяется к атрибуту
C: директива применяется к классу
M: директива применяется к комментарию
template - это привязка шаблона
compile - тут привязывается функция которая вызвается один AngularJS calls it once when html page is loaded
transclusion - внедряет шаблоны из вне, т.е. из внешнего файла.


Фильтры 
Фильтры позволяют провести некоторую предобработку перед выводом данных на страницу, например, отсортировать или как-то изменить набор данных.
{{question.text | lowercase}}
кастомный фильтр
questApp.filter('formatText', function(){
    return function(text){
        if(text.indexOf("фигасе")!==-1){
            return "***";
        }
        else{
            return text;
        }
    }
})

Сервисы
синтаксис
questApp.factory('dataService', function(){
Сервисы AngularJS представляют специальные объекты или функции, выполняющие некоторые общие для всего приложения задачи. В AngularJS имеюся ряд встроенных сервисов, такие как $http, $q и ряд других. Кроме того, имеется возможность создавать свои сервисы для выполнения специфических задач.
-$compile представляет функцию, генерирующую контент из фрагментов html. Чтобы наполнить контент данными из контроллера, в функцию передается параметр scope: compileFn(scope);
Запросы
$http({
  method: 'GET',
  url: '/someUrl'
}).then(function successCallback(response) {    
  }, function errorCallback(response) {       
  });
$q
var deferred = $q.defer();
Суть создания deferred-объекта заключается в том, что он раскрывает, во-первых, api по выполнению операций. А во-вторых, он содержит ассоциированный promise-объект, и через deferred-объект мы взаимодействуем с promise-объектом. Чтобы получить promise-объект, в самом конце функции используется следующее выражение return deferred.promise.
$anchorScroll: перемещает полосу прокрутки к определенной ссылке на странице
$document: предоставляет объект jqLite, который содержит стандартный объект window.document
$interval: представляет обертку вокруг функции window.setInterval
$location: предоставляет доступ к URL
$window: предоставляет стандартный javascript-объект window
$sce: удаляет потенциально опасные элементы и атрибуты из кода html
$sanitize: заменяет потенциально опасные символы эскейп-последовательностями

Маршрутизация
var questApp = angular.module('questApp', ["ngRoute"])
    .config(function($routeProvider){
        $routeProvider.when('/question',
        {
            templateUrl:'views/question.html',
            controller:'QuestionController'
        });
        $routeProvider.when('/answer',
        {
            templateUrl:'views/answer.html',
            controller:'AnswerController'
        });
        $routeProvider.when("/edit/:id", {
            templateUrl: "views/answer.html",
            controller:'AnswerController'
        });
        $routeProvider.when("/edit/:id/:data*", {
            templateUrl: "views/answer.html",
            controller:'AnswerController'
        });
        $routeProvider.otherwise({redirectTo: '/question'});
});
$route мы можем управлять текущим маршрутом. Сервис $route имеет несколько свойств и методов, позволяющих управлять маршрутом:
current: возвращает объект, который содержит информацию о текущем маршруте
reload(): перезагружает представление для текущего маршрута
routes: возвращает коллекцию маршрутов, определенных через $routeProvider
Чтобы зафиксировать переход от одного маршрута к другому, мы можем обрабатывать события, определенные в сервисе $route:
$routeChangeStart: событие срабатывает перед изменением маршрута
$routeChangeSuccess: событие срабатывает после изменения маршрута
$routeUpdate: событие срабатывает при обновлении маршрута
$routeChangeError: срабатывает, если маршрут не может быть изменен


Внедрение зависимостей и сервис $injector
в реальном проекте
todos.TodoCtrl.$inject
это достигается путем того что $inject это статическое свойство но можно писать прямо TodoCtrl.$inject
public static $inject = [
			'$scope',
			'$rootScope'
		];

$injector. Его роль состоит в определении и установке зависимостей, которые используются функцией.
Свою функциональность сервис $injector реализует с помощью следующих методов:
annotate(fn): возвращает набор зависимостей для функции fn
get(name): возвращает контретную реализацию сервиса по определенному названию сервиса
has(name): возвращает true, если для указанного объекта name установлена зависимость
invoke(fn, self, locals): вызывает функцию fn. Может принимать два необязательных параметра: self (позволяет установить аргумент this для вызываемой функции) и locals (представляет альтернативный способ передачи аргументов в вызываемую функцию)
angular.module("myApp", []).controller("myController", function ($scope, $injector) {
    var counter = 0;
    var getData = function (dataService, message) {
        if (counter %2 == 0) {
            console.log(dataService.question);
        } 
        else {
            console.log(message);
        }
        counter++;
    }
    $scope.buttonClick = function () {
        var deps = $injector.annotate(getData);
        var args = [];
        for (var i = 0; i < deps.length; i++) {
            if ($injector.has(deps[i])) {
                args.push($injector.get(deps[i]));
                console.log("Сервис: " + deps[i]);
            } 
            else if (deps[i] == "message") {
                args.push("Привет мир");
                console.log("" + deps[i]);
            }
        }
        getData.apply(null, args);
    };
}).factory('dataService', function(){
    return{
        question:{
            text: 'Какой js-фреймворк лучше использовать?',
            author: 'Иван Иванов',
            date: '20/10/2013'
        }
    };
});

















Работа со структурой DOM
Навигация по странице
Для навигации по html-странице мы можем применять ряд методов:
children(): возвращает набор дочерних элементов
eq(index): возвращает элемент по определенному индексу из коллекции элементов
find(tag): получает все элементы по определенному тегу
next(): возвращает следующий сестринский элемент
parent(): возвращает родительский элемент
html(): возвращает html-код элемента
text(): возвращает текстовое содержимое элементаПодобная функциональность реализована с помощью специального API, которое во многом напоминает jQuery и называется jqLite (jQuery - lite)
Манипуляция элементами
addClass(name): добавляет к элементу класс
attr(name) / attr(name, value): получает значение value атрибута name элемента и устанавливает его
css(name) / css(name, value): получает значение value стиля name у элемента и устанавливает его
hasClass(name): возвращает true, если элемент имеет класс name
prop(name) / prop(name, value): получает значение value свойстваа name элемента и устанавливает его
removeAttr(name): удаляет у элемента атрибут
removeClass(name): удаляет у элемента класс
text(value): устанавливает текстовое значение у элемента
toggleClass(name): переключает класс - класс name добавляется, а все ранее имевшиеся классы удаляются
val() / val(value): получает значение атрибута value и устанавливает его значение
Создание и удаление элементов
Следующие методы позволяют управлять созданием и удалением элементов:
angular.element(html): создает определенный элемент с кодом html
after(elements): добавляет элементы elements после элемента, на котором вызывается данный метод
append(elements): добавляет элементы elements в качестве дочерних в конец элемента, на котором вызывается данный метод
clone(): создает копию элемента, для которого вызывается метод
prepend(elements): добавляет элементы elements в качестве дочерних в начало элемента, на котором вызывается данный метод
remove(): удаляет элемент
replaceWith(element): заменяет элемент, на котором вызывается метод, другим элементом, который передается в качестве параметра
wrap(element): обертывает элемент, на котором вызывается метод, новым элементом, передающимся в качестве параметра
Регистрация событий
jqLite поддерживает регистрацию стандартных событий javascript. Для этого определены методы:
on(events, handler): регистрирует обработчик для одного или нескольких событий
off(events, handler): удаляет ранее зарегистрированный обработчик для нескольких событий
triggerHandler(event): вызывает обработчики для события


Директивы
1 ng-repeat позволяет производить обход массивов в стиле цикла for-each
<li ng-repeat="phone in phones">
2 ng-bind: осуществляет привязку к свойству innerText html-элемента односторонняя привязка<span ng-bind="phones.length">
3 ng-bind-html: позволяет выводить на страницу html-содержимое со всеми тегами.
<p ng-bind-html="htmlcode"></p>
4 ng-bind-template позволяет задать шаблон привязки с использованием выражений
<p ng-bind-template="{{phones[0].name}}: {{phones[0].price}} $"></p>
5 ng-model: создает двустороннюю привязку
<input type="text" ng-model="property" />
6 ng-non-bindable: определяет участок html-кода, в котором привязка не будет использоваться
<p ng-non-bindable>{{1 + 2}}</p>
7 ng-include получает с веб-сервера фрагмент кода HTML, обрабатывает его и добавляет на html-страницу. Подобные фрагменты называются частичными представлениями
может принимать три параметра:
-src: url загружаемого файла
-onload: определяет выражение, которое рендерится при загрузке файла
-autoscroll: определяет, допускается ли прокрутка во время загрузки файла
<ng-include src="'phonesList.html'"></ng-include>
8 ng-switch - как стандартный свич, определить фрагменты кода html сразу же на главной странице и отображать их в зависимости от условий. Для этого предназначена директива 
    <div ng-switch on="data.mode"> - тут передается объект
    <div ng-switch-when="Tablets"> - тут выбирается показывать или нет значение объекта data.mode
    <div ng-switch-when="Tablets2"> - тут выбирается показывать или нет значение объекта data.mode
    <div ng-switch-default>   - это значение по умолчанию
9 ng-style: устанавливает у элемента стили css
10 ng-class: задает элементу определенный класс
11 ng-class-even: устанавливает класс для четных элементов
12 ng-class-odd: устанавливает класс для нечетных элементов
13 ng-hide: скрывает элемент
14 ng-show: делает элемент видимым
15 ng-if: задает для элемента некоторое условие
ng-blur: определяет поведение для события blur, которое возникает при потере элементом фокуса
ng-focus: определяет поведение для события focus, которое возникает при получении фокуса элементом
ng-change: определяет поведение для события change, которое возникает при изменении элементом состояния, например, при нажатии на элемент input type="checkbox"
ng-submit: определяет поведение для события submit, которое возникает при отправке формы
ng-copy/ng-cut/ng-paste: определяет поведение для событий копирования, вырезки и вставки соответственно
ng-blclick: та же ng-click, только обрабатывается двойное нажатие
ng-mousedown: для обработки нажатия клавиши мыши
ng-mouseup: для обработки отжатия мыши
ng-mouseenter: для обработки наведения курсора в определенную область
ng-mouseleave: для обработки ухода курсора с определенной области
ng-mousemove: для обработки перемещения курсора мыши
ng-keydown: обработка нажатия клавишы клавиатуры
ng-keypress: обработка нажатия клавишы клавиатуры


Создание проекта с ангуляром жс и тайпскриптом
в папк добавим файл пакаджа
$ npm init - тут просто создаем файл с именем package.json но т.к.  это не обычная команда создания то мы увидим диалог по поэтапному созданию файла пакета для загрузки всего остального
- добавляем тайпскрипт
npm install typescript --save-dev
We use the --save-dev flag so that this dev dependency is saved into the package.json file.
Before we can start using TypeScript we need to install the definition files. Definition files (sometimes referred to as header files in other languages) do not contain any code, rather, they describe the API for a third-party library; whether that is jQuery, React or Angular.
Let's install the TypeScript definitions for Angular
npm install @types/angular --save
создадим tsconfig.json файл и наполним его
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es5"
  },
  "files": ["script.ts"]
}
We will have a single script.ts file that will be compiled to script.js, which will be included in our HTML template.
To compile our TypeScript from the root of our application execute the following command:
т.е. если хотим комилировать то вводим это
$ node_modules/.bin/tsc
Дальше смотреть по пунктам пример
https://brianflove.com/2016/12/26/typing-up-your-angular-1-app/

Передача между соседними контроллерами
https://benohead.com/blog/2016/07/18/angularjs-sharing-data-controllers/
1 Между соседними конроллерми с помощью  "$scope",
в первом контоллере 
$rootScope.$broadcast("namechanged", $scope.name); это генерирует рассылку сообщений по всем контроллерам

это подписка на событие в любом контроллере, т.е. мы получим тригер события сразу же
$scope.$on("namechanged", function(event, name) {
  $scope.name = name;
});
2 Передаче между бобытиями через сервис
создать сервис с методом гет и сет, но минус в том что нет тригера события нужно придумать как обновить данные и понять что они изменилисьб

112/5000
$ broadcast используется для запуска события и его распространения в текущей области и рекурсивно для всех дочерних областей
$emit is used to trigger an event and propagate it to the current scope and recursively to all parent scopes
$on is used to listen to event notification on the scope
$watch - следит за изменением переменных в своем $scope



…or create a new repository on the command line
echo "# AngJsTypeFist" >> README.md
git init
git add *
git commit -m "first commit"
git remote add origin https://github.com/DenisDVG/typescript-angular.git
git push -u origin master

Для мержа в визуал код нужно набрать
ctrl+shift+p

npm run start:dev-evo

http://Kovalev.IG:1GYJaSlm@tfs.parma.ru:8080/tfs/PARMA/GASPS-17/_git/gasps
http://Kovalev.IG:1GYJaSlm@tfs.parma.ru:8080/tfs/PARMA/GASPS-17/_git/gasps

Фиксы ошибок

выпадала ошибка с sass препроцессором, фиксанул этой строкой
npm rebuild --force

это комитит все вообще все!
git push --set-upstream origin feature/T190004pr --no-verify
а это нормальный пуш
git push --set-upstream origin feature/223705_

запуск сервера 
npm start вместо ng serve

что бы запустить коммит
git commit
что бы потом запушить ветку
git push --set-upstream origin feature/211239





разобрать код

  private readonly filter$ = new BehaviorSubject<string>('');

  private readonly sliceId$ = new BehaviorSubject<number | undefined>(undefined);

  readonly dataSlices$ = this.selectedEntities$.pipe(
    switchMap(selectedEntities => this.getDataSlices(selectedEntities)),
    shareReplay({ bufferSize: 1, refCount: true }),
  );

  readonly dictItemsFilter: Observable<DictItemsGridItem[]> = this.selectFilteredList();



 private selectFilteredList() {
    const dictItems: Observable<DictItemsGridItem[]> = this.sliceId$.pipe(
      withLatestFrom(this.dataSlices$),
      map(([sliceId, items]) => items.find(item => item.id === sliceId)),
      switchMap(sliceItem => {
        if (
          sliceItem === undefined ||
          sliceItem.dataType !== this.TypeDataSlides.catalog ||
          sliceItem.dictId === null
        ) {
          return of([]);
        }

        return this.loadDictItems(sliceItem.dictId, undefined);
      }),
    );

    const filterDebounceTime = 300;

    const filter$ = this.filter$.pipe(debounceTime(filterDebounceTime));

    return combineLatest([dictItems, filter$]).pipe(
      map(([items, query]) => items.filter(item => item.title.toLocaleLowerCase().indexOf(query.toLowerCase()) >= 0)),
      shareReplay({ bufferSize: 1, refCount: true }),
    );








